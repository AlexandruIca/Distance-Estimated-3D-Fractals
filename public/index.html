<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Distance-estimated 3D fractals</title>

    <meta name="description" content="A workbench for experimenting with distance-estimated fractals.">
    <meta property="og:title" content="Distance-estimated 3D fractals">
    <meta property="og:description" content="A workbench for experimenting with distance-estimated fractals.">
    <meta property="og:type" content="website">

    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            background-color: black;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="webgl2_surface"></canvas>
    <script>
        const vertices = new Float32Array([
            -1.0, 1.0, 0.0, // top left
            -1.0, -1.0, 0.0, // bottom left
            1.0, -1.0, 0.0, // bottom right
            1.0, -1.0, 0.0, // bottom right
            1.0, 1.0, 0.0, // top right
            -1.0, 1.0, 0.0 // top left
        ]);

        const vertexShader = `
        #version 300 es

        in vec3 position;
        out vec3 vPosition;
        
        void main()
        {
            vPosition = position;
            gl_Position = vec4(position, 1.0);
        }
        `;

        const fragmentShader = `
        #version 300 es
        precision highp float;

        in vec3 vPosition;
        out vec4 fragColor;

        uniform vec3 uLightPosition;
        uniform vec4 uCoeffs;

        float distance_from_sphere(in vec3 p, in vec3 c, in float r)
        {
            return length(p - c) - r;
        }

        float map_the_world(in vec3 p)
        {
            float displacement = sin(uCoeffs.x * p.x) * sin(uCoeffs.y * p.y) * sin(uCoeffs.z * p.z) * uCoeffs.w;
            float sphere = distance_from_sphere(p, vec3(0.0), 1.0);
            return sphere + displacement;
        }

        vec3 compute_normal(in vec3 p)
        {
            const vec3 small_step = vec3(0.001, 0.0, 0.0);

            float gradient_x = map_the_world(p + small_step.xyy) - map_the_world(p - small_step.xyy);
            float gradient_y = map_the_world(p + small_step.yxy) - map_the_world(p - small_step.yxy);
            float gradient_z = map_the_world(p + small_step.yyx) - map_the_world(p - small_step.yyx);

            vec3 normal = vec3(gradient_x, gradient_y, gradient_z);

            return normalize(normal);
        }

        vec4 ray_march(in vec3 ray_origin, in vec3 ray_direction)
        {
            float total_distance_travelled = 0.0;
            const int NUMBER_OF_STEPS = 32;
            const float MINIMUM_HIT_DISTANCE = 0.001;
            const float MAXIMUM_TRACE_DISTANCE = 1000.0;

            for (int i = 0; i < NUMBER_OF_STEPS; ++i) {
                vec3 current_position = ray_origin + total_distance_travelled * ray_direction;
                float distance_to_closest = map_the_world(current_position);

                if (distance_to_closest < MINIMUM_HIT_DISTANCE) {
                    vec3 normal = compute_normal(current_position);
                    vec3 light_direction = normalize(current_position - uLightPosition);
                    float diffuse_intensity = max(0.0, dot(normal, light_direction));
                    return vec4(vec3(1.0, 0.0, 0.0) * diffuse_intensity, distance_to_closest * 1000.0);
                }

                if (total_distance_travelled > MAXIMUM_TRACE_DISTANCE) {
                    break;
                }

                total_distance_travelled += distance_to_closest;
            }

            return vec4(0.0);
        }

        void main()
        {
            vec3 camera_position = vec3(0.0, 0.0, -5.0);
            vec3 ray_origin = camera_position;
            vec3 ray_direction = vec3(vPosition.xy, 1.0);
            fragColor = ray_march(ray_origin, ray_direction);
        }
        `;

        function createWebGL2Context(id, options, onError) {
            const canvas = document.getElementById(id);

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const gl = canvas.getContext('webgl2', options);

            if (!gl) {
                onError("WebGL 2 is not available!");
                canvas.parentElement.innerHTML = "This example requires WebGL 2 which is unavailable on this device.";
            } else {
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.clearColor(0, 0, 0, 1);
            }

            return gl;
        }

        function createPipeline(gl, vertexShaderSource, fragmentShaderSource, onError) {
            const vertShader = gl.createShader(gl.VERTEX_SHADER);
            const fragShader = gl.createShader(gl.FRAGMENT_SHADER);

            gl.shaderSource(vertShader, vertexShaderSource.trim());
            gl.compileShader(vertShader);

            if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
                onError(gl.getShaderInfoLog(vertShader));
            }

            gl.shaderSource(fragShader, fragmentShaderSource.trim());
            gl.compileShader(fragShader);

            if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
                onError(gl.getShaderInfoLog(fragShader));
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                onError(gl.getProgramInfoLog(program));
            }

            return program;
        }

        function createAndBindVertexBuffer(gl, program, vertices) {
            const vertexBuffer = gl.createBuffer();
            const positionCoord = gl.getAttribLocation(program, "position");
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.vertexAttribPointer(positionCoord, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(positionCoord);

            return vertexBuffer;
        }

        const gl = createWebGL2Context('webgl2_surface', { antialias: true }, console.error);

        const program = createPipeline(gl, vertexShader, fragmentShader, console.error);
        gl.useProgram(program);

        const screenArray = gl.createVertexArray();
        gl.bindVertexArray(screenArray);

        const vertexBuffer = createAndBindVertexBuffer(gl, program, vertices);

        let lightPosition = [0.0, 0.0, 5.0];
        let radians = 0.0;
        const radiansOffset = 0.05;
        const lightPositionLocation = gl.getUniformLocation(program, "uLightPosition");
        gl.uniform3fv(lightPositionLocation, lightPosition);

        let coeffs = [5.0, 5.0, 5.0, 0.25];
        const coeffsLimits = { lower: -30.0, upper: 30.0 };
        let coeffsFactors = { x: 1.0, y: -1.0, offset: 0.1 };
        const coeffsLocation = gl.getUniformLocation(program, "uCoeffs");
        gl.uniform4fv(coeffsLocation, coeffs);

        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT);

            lightPosition[0] = 10.0 * Math.cos(radians);
            lightPosition[1] = 10.0 * Math.sin(radians);
            gl.uniform3fv(lightPositionLocation, lightPosition);

            radians += radiansOffset;
            radians %= 2.0 * Math.PI;

            coeffs[0] += coeffsFactors.offset * coeffsFactors.x;
            coeffs[1] -= coeffsFactors.offset * coeffsFactors.y;
            if (coeffs[0] < coeffsLimits.lower || coeffs[0] > coeffsLimits.upper) {
                coeffsFactors.x *= -1.0;
            }
            if (coeffs[1] < coeffsLimits.lower || coeffs[1] > coeffsLimits.upper) {
                coeffsFactors.y *= -1.0;
            }
            gl.uniform4fv(coeffsLocation, coeffs);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            window.requestAnimationFrame(render);
        }

        window.requestAnimationFrame(render);
    </script>
</body>

</html>