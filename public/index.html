<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Distance-estimated 3D fractals</title>

    <meta name="description" content="A workbench for experimenting with distance-estimated fractals.">
    <meta property="og:title" content="Distance-estimated 3D fractals">
    <meta property="og:description" content="A workbench for experimenting with distance-estimated fractals.">
    <meta property="og:type" content="website">

    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            background-color: black;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="triangleCanvas"></canvas>
    <script>
        const vertices = new Float32Array([
            -1.0, 1.0, 0.0, // top left
            -1.0, -1.0, 0.0, // bottom left
            1.0, -1.0, 0.0, // bottom right
            1.0, -1.0, 0.0, // bottom right
            1.0, 1.0, 0.0, // top right
            -1.0, 1.0, 0.0 // top left
        ]);

        const vertexShader = `
        #version 300 es

        in vec3 position;
        out vec3 vPosition;
        
        void main()
        {
            vPosition = position;
            gl_Position = vec4(position, 1.0);
        }
        `;

        const fragmentShader = `
        #version 300 es
        precision highp float;

        in vec3 vPosition;
        out vec4 fragColor;

        float distance_from_sphere(in vec3 p, in vec3 c, in float r)
        {
            return length(p - c) - r;
        }

        float map_the_world(in vec3 p)
        {
            float displacement = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25;
            float sphere = distance_from_sphere(p, vec3(0.0), 1.0);
            return sphere + displacement;
        }

        vec3 compute_normal(in vec3 p)
        {
            const vec3 small_step = vec3(0.001, 0.0, 0.0);

            float gradient_x = map_the_world(p + small_step.xyy) - map_the_world(p - small_step.xyy);
            float gradient_y = map_the_world(p + small_step.yxy) - map_the_world(p - small_step.yxy);
            float gradient_z = map_the_world(p + small_step.yyx) - map_the_world(p - small_step.yyx);

            vec3 normal = vec3(gradient_x, gradient_y, gradient_z);

            return normalize(normal);
        }

        vec4 ray_march(in vec3 ray_origin, in vec3 ray_direction)
        {
            float total_distance_travelled = 0.0;
            const int NUMBER_OF_STEPS = 32;
            const float MINIMUM_HIT_DISTANCE = 0.001;
            const float MAXIMUM_TRACE_DISTANCE = 1000.0;

            for (int i = 0; i < NUMBER_OF_STEPS; ++i) {
                vec3 current_position = ray_origin + total_distance_travelled * ray_direction;
                float distance_to_closest = map_the_world(current_position);

                if (distance_to_closest < MINIMUM_HIT_DISTANCE) {
                    vec3 normal = compute_normal(current_position);
                    vec3 light_position = vec3(2.0, -5.0, 3.0);
                    vec3 light_direction = normalize(current_position - light_position);
                    float diffuse_intensity = max(0.0, dot(normal, light_direction));
                    return vec4(vec3(1.0, 0.0, 0.0) * diffuse_intensity, distance_to_closest * 1000.0);
                }

                if (total_distance_travelled > MAXIMUM_TRACE_DISTANCE) {
                    break;
                }

                total_distance_travelled += distance_to_closest;
            }

            return vec4(0.0);
        }

        void main()
        {
            vec3 camera_position = vec3(0.0, 0.0, -5.0);
            vec3 ray_origin = camera_position;
            vec3 ray_direction = vec3(vPosition.xy, 1.0);
            fragColor = ray_march(ray_origin, ray_direction);
        }
        `;

        const canvas = document.getElementById('triangleCanvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const gl = canvas.getContext('webgl2', { antialias: true });

        if (!gl) {
            console.error("WebGL 2 is not available!");
            document.body.innerHTML = "This example requires WebGL 2 which is unavailable on this device.";
        }

        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

        const vertShader = gl.createShader(gl.VERTEX_SHADER);
        const fragShader = gl.createShader(gl.FRAGMENT_SHADER);

        gl.shaderSource(vertShader, vertexShader.trim());
        gl.compileShader(vertShader);
        if (gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
            console.log(gl.getShaderInfoLog(vertShader));
        }

        gl.shaderSource(fragShader, fragmentShader.trim());
        gl.compileShader(fragShader);
        if (gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
            console.log(gl.getShaderInfoLog(fragShader));
        }

        const prog = gl.createProgram();
        gl.attachShader(prog, vertShader);
        gl.attachShader(prog, fragShader);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(prog));
        }
        gl.useProgram(prog);

        const screenArray = gl.createVertexArray();
        gl.bindVertexArray(screenArray);

        const vertexBuffer = gl.createBuffer();
        const positionCoord = gl.getAttribLocation(prog, "position");
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.vertexAttribPointer(positionCoord, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionCoord);

        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    </script>
</body>

</html>